<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Technical Documentation</title>
</head>
<body>
	<nav id="navbar">
		<header></header>
		<a href="" class="nav-link" id="1"></a>
		<a href="" class="nav-link" id="2"></a>
		<a href="" class="nav-link" id="3"></a>
		<a href="" class="nav-link" id="4"></a>
		<a href="" class="nav-link" id="5"></a>
		<a href="" class="nav-link" id="6"></a>
		<a href="" class="nav-link" id="7"></a>
		<a href="" class="nav-link" id="8"></a>
		<a href="" class="nav-link" id="9"></a>
		<a href="" class="nav-link" id="10"></a>
	</nav>
	<main id="main-doc">
		<section class="main-section" id="1">
			<h1>What are functions?</h1>
			<p>Generally speaking, a function is a "subprogram" that can be called by code external (or internal in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body. Values can be passed to a function, and the function will return a value.</p>
			<p>In JavaScript, functions are first-class objects, because they can have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called. In brief, they are Function objects.</p>
			<p>Every function in JavaScript is a Function object. See Function for information on properties and methods of Function objects.</p>
			<p>To return a value other than the default, a function must have a return statement that specifies the value to return. A function without a return statement will return a default value. In the case of a constructor called with the new keyword, the default value is the value of its this parameter. For all other functions, the default return value is undefined.</p>
			<p>The parameters of a function call are the function's arguments. Arguments are passed to functions by value. If the function changes the value of an argument, this change is not reflected globally or in the calling function. However, object references are values, too, and they are special: if the function changes the referred object's properties, that change is visible outside the function, as shown in the following example:</p>
			<code>
				/* Declare the function 'myFunc' */
				function myFunc(theObject) {
				  theObject.brand = "Toyota";
				}

				/*
				 * Declare variable 'mycar';
				 * create and initialize a new Object;
				 * assign reference to it to 'mycar'
				 */
				var mycar = {
				  brand: "Honda",
				  model: "Accord",
				  year: 1998
				};

				/* Logs 'Honda' */
				console.log(mycar.brand);

				/* Pass object reference to the function */
				myFunc(mycar);

				/*
				 * Logs 'Toyota' as the value of the 'brand' property
				 * of the object, as changed to by the function.
				 */
				console.log(mycar.brand);
			</code>

		</section>
		<section class="main-section" id="2">
			<h1>Defining functions</h1>
			<p>There are several ways to define functions:</p>
			
			<h2>The function declaration (function statement)</h2>
			<p>There is a special syntax for declaring functions:</p>
			<code>
function name([param[, param[, ... param]]]) {
 statements
}
			</code>
			<h3>name</h3>
			<p>The function name.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>
			<h2>The function expression (function expression)</h2>
			<p>A function expression is similar to and has the same syntax as a function declaration (see function expression for details). A function expression may be a part of a larger expression. One can define "named" function expressions (where the name of the expression might be used in the call stack for example) or "anonymous" function expressions. Function expressions are not hoisted onto the beginning of the scope, therefore they cannot be used before they appear in the code.</p>
			<code>function [name]([param[, param[, ... param]]]) {
   statements
}</code>
			<h3>name</h3>
			<p>The function name. Can be omitted, in which case the function becomes known as an anonymous function.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>

<!-- The generator function declaration (function* statement) -->

			<h2>The generator function declaration (function* statement)</h2>
			<p>There is a special syntax for generator function declarations (see function* statement for details):</p>
			<code>
				function* name([param[, param[, ... param]]]) {
   statements
}
			</code>
			<h3>name</h3>
			<p>The function name.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>
			<h2>The generator function expression (function* expression)</h2>
			<p>A generator function expression is similar to and has the same syntax as a generator function declaration.</p>
			<code>
				function* [name]([param[, param[, ... param]]]) {
   statements
}			
			</code>
			<h3>name</h3>
			<p>The function name. Can be omitted, in which case the function becomes known as an anonymous function.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>
			<h2>The arrow function expression (=>)</h2>
			<p>An arrow function expression has a shorter syntax and lexically binds its this value.</p>
			<code>
				([param[, param]]) => {
   statements
}

param => expression
			</code>
			<h3>param</h3>
			<p>The name of an argument. Zero arguments need to be indicated with ().  For only one argument, the parentheses are not required. (like foo => 1)</p>
			<h3>statements or expression</h3>
			<p>Multiple statements need to be enclosed in brackets. A single expression requires no brackets. The expression is also the implicit return value of the function.</p>
		</section>

		<section class="main-section" id="3">
			<h1>Function parameters</h1>
			<h2>Default parameters</h2>
			<p>Default function parameters allow formal parameters to be initialized with default values if no value or undefined is passed.</p>
			<h2>Rest parameters</h2>
			<p>The rest parameter syntax allows representing an indefinite number of arguments as an array.</p>
		</section>

		<section class="main-section" id="4">
			<h1>The arguments object</h1>
			<p>You can refer to a function's arguments within the function by using the arguments object.</p>
			<p>The arguments object is a local variable available within all (non-arrow) functions. You can refer to a function's arguments within the function by using the arguments object. This object contains an entry for each argument passed to the function, the first entry's index starting at 0.</p>
			<p>The arguments object is not an Array. It is similar to an Array, but does not have any Array properties except length. For example, it does not have the pop method. </p>
		</section>

		<section class="main-section" id="5">
			<h1>Defining method functions</h1>
			<h2>Getter and setter functions</h2>
			<p>You can define getters (accessor methods) and setters (mutator methods) on any standard built-in object or user-defined object that supports the addition of new properties. The syntax for defining getters and setters uses the object literal syntax.</p>
			<h3>get</h3>
			<p>Binds an object property to a function that will be called when that property is looked up.</p>
			<h3>set</h3>
			<p>Binds an object property to a function to be called when there is an attempt to set that property.</p>
			<h2>Method definition syntax</h2>
			<p>Starting with ECMAScript 2015, you are able to define own methods in a shorter syntax, similar to the getters and setters.</p>
			<code>var obj = {
  foo() {},
  bar() {}
};</code>
		</section>

		<section class="main-section" id="6">
			<h1>Constructor vs. declaration vs. expression</h1>
			<p>There is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or undefined if the function name was previously declared via a var statement). For example:</p>
			<code>var y = function x() {};
alert(x); // throws an error</code>
			<p>The function name also appears when the function is serialized via Function's toString method.</p>
			<p>On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.</p>
			<p>A function defined by 'new Function' does not have a function name. However, in the SpiderMonkey JavaScript engine, the serialized form of the function shows as if it has the name "anonymous". For example, alert(new Function()) outputs:</p>
			<code>function anonymous() {
}</code>
			<p>A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a Function constructor does not inherit any scope other than the global scope (which all functions inherit).</p>
		</section>

		<section class="main-section" id="7">
			<h1>Block-level functions</h1>
			<p>In strict mode, starting with ES2015, functions inside blocks are now scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.</p>
			<h2>Block-level functions in non-strict code</h2>
			<p>In a word: Don't.</p>
			<p>In non-strict code, function declarations inside blocks behave strangely. For example:</p>
			<code>if (shouldDefineZero) {
   function zero() {     // DANGER: compatibility risk
      console.log("This is zero.");
   }
}</code>
			<p>ES2015 says that if shouldDefineZero is false, then zero should never be defined, since the block never executes. However, it's a new part of the standard. Historically, this was left unspecified, and some browsers would define zero whether the block executed or not.</p>
			<p>In strict mode, all browsers that support ES2015 handle this the same way: zero is defined only if shouldDefineZero is true, and only in the scope of the if-block.</p>
		</section>
	</main>
</body>
</html>