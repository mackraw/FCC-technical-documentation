<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>JavaScript Functions - Technical Documentation</title>
</head>
<body>
	<nav id="navbar">
		<header id="nav-head">JavaScript Functions</header>
		<a href="#What_are_functions" class="nav-link">What are functions</a>
		<a href="#Defining_functions" class="nav-link">Defining functions</a>
		<a href="#Function_parameters" class="nav-link">Function parameters</a>
		<a href="#The_arguments_object" class="nav-link">The arguments object</a>
		<a href="#Defining_method_functions" class="nav-link">Defining method functions</a>
		<a href="#Constructor_vs_declaration_vs_expression" class="nav-link">Constructor vs declaration vs expression</a>
		<a href="#Block_level_functions" class="nav-link">Block level functions</a>
		<a href="#Function_scope" class="nav-link">Function scope</a>
		<a href="#Scope_and_the_function_stack" class="nav-link">Scope and the function stack</a>
		<a href="#Closures" class="nav-link">Closures</a>
		<a href="#Reference" class="nav-link">Reference</a>
	</nav>
	<main id="main-doc">
		<section class="main-section" id="What_are_functions">
			<header>What are functions</header>
			<p>Generally speaking, a function is a "subprogram" that can be called by code external (or internal in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body. Values can be passed to a function, and the function will return a value.</p>
			<p>In JavaScript, functions are first-class objects, because they can have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called. In brief, they are Function objects.</p>
			<p>Every function in JavaScript is a Function object. See Function for information on properties and methods of Function objects.</p>
			<p>To return a value other than the default, a function must have a return statement that specifies the value to return. A function without a return statement will return a default value. In the case of a constructor called with the new keyword, the default value is the value of its this parameter. For all other functions, the default return value is undefined.</p>
			<p>The parameters of a function call are the function's arguments. Arguments are passed to functions by value. If the function changes the value of an argument, this change is not reflected globally or in the calling function. However, object references are values, too, and they are special: if the function changes the referred object's properties, that change is visible outside the function, as shown in the following example:</p>
			<div class="codeblock">
				<code>
<pre>/* Declare the function 'myFunc' */
function myFunc(theObject) {
  theObject.brand = "Toyota";
}

/*
 * Declare variable 'mycar';
 * create and initialize a new Object;
 * assign reference to it to 'mycar'
 */
var mycar = {
  brand: "Honda",
  model: "Accord",
  year: 1998
};

/* Logs 'Honda' */
console.log(mycar.brand);

/* Pass object reference to the function */
myFunc(mycar);

/*
 * Logs 'Toyota' as the value of the 'brand' property
 * of the object, as changed to by the function.
 */
console.log(mycar.brand);</pre>
				</code>
			</div>

		</section>

		<section class="main-section" id="Defining_functions">
			<header>Defining functions</header>
			<p>There are several ways to define functions:</p>
			
			<h2>The function declaration (function statement)</h2>
			<p>There is a special syntax for declaring functions:</p>
			<div class="codeblock">
  	    <code>
<pre>function name([param[, param[, ... param]]]) {
 statements
}</pre>
			  </code>
		  </div>
			<h3>name</h3>
			<p>The function name.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>
			
			<h2>The function expression (function expression)</h2>
			<p>A function expression is similar to and has the same syntax as a function declaration (see function expression for details). A function expression may be a part of a larger expression. One can define "named" function expressions (where the name of the expression might be used in the call stack for example) or "anonymous" function expressions. Function expressions are not hoisted onto the beginning of the scope, therefore they cannot be used before they appear in the code.</p>
			<div class="codeblock">
			  <code>
<pre>function [name]([param[, param[, ... param]]]) {
  statements
}</pre>
		        </code>
			    </div>
			<h3>name</h3>
			<p>The function name. Can be omitted, in which case the function becomes known as an anonymous function.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>
			<h2>The generator function declaration (function* statement)</h2>
			<p>There is a special syntax for generator function declarations (see function* statement for details):</p>
			<div class="codeblock">
				<code>
<pre>function* name([param[, param[, ... param]]]) {
  statements
}</pre>
				</code>
			</div>
			<h3>name</h3>
			<p>The function name.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>

			<h2>The generator function expression (function* expression)</h2>
			<p>A generator function expression is similar to and has the same syntax as a generator function declaration.</p>
      <div class="codeblock">
	      <code>
<pre>function* [name]([param[, param[, ... param]]]) {
  //statements
}</pre>
			  </code>
		  </div>
			<h3>name</h3>
			<p>The function name. Can be omitted, in which case the function becomes known as an anonymous function.</p>
			<h3>param</h3>
			<p>The name of an argument to be passed to the function. A function can have up to 255 arguments.</p>
			<h3>statements</h3>
			<p>The statements comprising the body of the function.</p>

			<h2>The arrow function expression (=>)</h2>
			<p>An arrow function expression has a shorter syntax and lexically binds its this value.</p>
			<div class="codeblock">
				<code>
<pre>([param[, param]]) => {
  statements
}

param => expression</pre>
				</code>
			</div>
			<h3>param</h3>
			<p>The name of an argument. Zero arguments need to be indicated with ().  For only one argument, the parentheses are not required. (like foo => 1)</p>
			<h3>statements or expression</h3>
			<p>Multiple statements need to be enclosed in brackets. A single expression requires no brackets. The expression is also the implicit return value of the function.</p>
		</section>

		<section class="main-section" id="Function_parameters">
			<header>Function parameters</header>
			<h2>Default parameters</h2>
			<p>Default function parameters allow formal parameters to be initialized with default values if no value or undefined is passed.</p>
			<h2>Rest parameters</h2>
			<p>The rest parameter syntax allows representing an indefinite number of arguments as an array.</p>
		</section>

		<section class="main-section" id="The_arguments_object">
			<header>The arguments object</header>
			<p>You can refer to a function's arguments within the function by using the arguments object.</p>
			<p>The arguments object is a local variable available within all (non-arrow) functions. You can refer to a function's arguments within the function by using the arguments object. This object contains an entry for each argument passed to the function, the first entry's index starting at 0.</p>
			<p>The arguments object is not an Array. It is similar to an Array, but does not have any Array properties except length. For example, it does not have the pop method. </p>
		</section>

		<section class="main-section" id="Defining_method_functions">
			<header>Defining method functions</header>
			<h2>Getter and setter functions</h2>
			<p>You can define getters (accessor methods) and setters (mutator methods) on any standard built-in object or user-defined object that supports the addition of new properties. The syntax for defining getters and setters uses the object literal syntax.</p>
			<h3>get</h3>
			<p>Binds an object property to a function that will be called when that property is looked up.</p>
			<h3>set</h3>
			<p>Binds an object property to a function to be called when there is an attempt to set that property.</p>
			<h2>Method definition syntax</h2>
			<p>Starting with ECMAScript 2015, you are able to define own methods in a shorter syntax, similar to the getters and setters.</p>
			<div class="codeblock">
				<code>
<pre>var obj = {
  foo() {},
  bar() {}
};</pre>
			  </code>
			</div>
		</section>

		<section class="main-section" id="Constructor_vs_declaration_vs_expression">
			<header>Constructor vs declaration vs expression</header>
			<p>There is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or undefined if the function name was previously declared via a var statement). For example:</p>
			<div class="codeblock">
				<code>
<pre>var y = function x() {};
alert(x); // throws an error</pre>
			  </code>
			</div>
			<p>The function name also appears when the function is serialized via Function's toString method.</p>
			<p>On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.</p>
			<p>A function defined by 'new Function' does not have a function name. However, in the SpiderMonkey JavaScript engine, the serialized form of the function shows as if it has the name "anonymous". For example, alert(new Function()) outputs:</p>
			<div class="codeblock">
				<code>
<pre>function anonymous() {
}</pre>
			  </code>
			</div>
			<p>A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a Function constructor does not inherit any scope other than the global scope (which all functions inherit).</p>
		</section>

		<section class="main-section" id="Block_level_functions">
			<header>Block level functions</header>
			<p>In strict mode, starting with ES2015, functions inside blocks are now scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.</p>
			<h2>Block-level functions in non-strict code</h2>
			<p>In a word: Don't.</p>
			<p>In non-strict code, function declarations inside blocks behave strangely. For example:</p>
			<div class="codeblock">
  			<code>
<pre>if (shouldDefineZero) {
  function zero() {     // DANGER: compatibility risk
    console.log("This is zero.");
  }
}</pre>
			  </code>
			</div>
			<p>ES2015 says that if shouldDefineZero is false, then zero should never be defined, since the block never executes. However, it's a new part of the standard. Historically, this was left unspecified, and some browsers would define zero whether the block executed or not.</p>
			<p>In strict mode, all browsers that support ES2015 handle this the same way: zero is defined only if shouldDefineZero is true, and only in the scope of the if-block.</p>
		</section>
		<section class="main-section" id="Function_scope">
			<header>Function scope</header>
			<p>Variables defined inside a function cannot be accessed from anywhere outside the function, because the variable is defined only in the scope of the function. However, a function can access all variables and functions defined inside the scope in which it is defined. In other words, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function and any other variable to which the parent function has access.</p>
		</section>
		
	  <section class="main-section" id="Scope_and_the_function_stack">
			<header>Scope and the function stack</header>
			<h2>Recursion</h2>
			<p>A function can refer to and call itself. There are three ways for a function to refer to itself:</p>
			<ol>
				<li>the function's name</li>
				<li>arguments.callee</li>
				<li>an in-scope variable that refers to the function</li>
			</ol>
			<p>For example, consider the following function definition:</p>
			<div class="codeblock">
				<code>
<pre>var foo = function bar() {
  // statements go here
};</pre>
				</code>
			</div>
			<p>Within the function body, the following are all equivalent:</p>
			<ol>
				<li>bar()</li>
				<li>arguments.callee()</li>
				<li>foo()</li>
			</ol>
			<p>A function that calls itself is called a recursive function. In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).</p>
		</section>

		<section class="main-section" id="Closures">
			<header>Closures</header>
			<p>Closures are one of the most powerful features of JavaScript. JavaScript allows for the nesting of functions and grants the inner function full access to all the variables and functions defined inside the outer function (and all other variables and functions that the outer function has access to). However, the outer function does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables of the inner function. Also, since the inner function has access to the scope of the outer function, the variables and functions defined in the outer function will live longer than the duration of the inner function execution, if the inner function manages to survive beyond the life of the outer function. A closure is created when the inner function is somehow made available to any scope outside the outer function.</p>
		</section>
		<section class="main-section last" id="Reference">
			<header>Reference</header>
			<p>All content taken from <a href="https://developer.mozilla.org">MDN</a>.</p>
		</section>
	</main>
</body>
</html>